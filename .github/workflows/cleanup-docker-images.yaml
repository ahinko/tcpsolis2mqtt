name: Cleanup Docker Images

on:
  schedule:
    # Run weekly on Sundays at 2 AM UTC
    - cron: "0 2 * * 0"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Dry run mode (just show what would be deleted)"
        required: false
        default: true
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup Docker images
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ github.event_name == 'workflow_dispatch' && inputs.dry_run || 'false' }}
        run: |
          set -e

          if [ "$DRY_RUN" = "true" ]; then
            echo "🔍 DRY RUN MODE - No images will be deleted"
          else
            echo "🗑️  CLEANUP MODE - Images will be deleted"
          fi

          echo "🔍 Fetching all package versions..."

          # Get all package versions (using user endpoint)
          PACKAGE_NAME=$(echo "${{ github.repository }}" | cut -d'/' -f2)
          echo "Looking for package: $PACKAGE_NAME"
          echo "Owner: ${{ github.repository_owner }}"
          
          # First check if we can access the package
          if ! gh api "users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME" > /dev/null 2>&1; then
            echo "❌ Cannot access package. Available packages:"
            gh api "users/${{ github.repository_owner }}/packages?package_type=container" --jq '.[].name' || echo "No packages found"
            exit 1
          fi
          
          # Get all package versions
          if ! gh api --paginate "users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME/versions" > raw_versions.json; then
            echo "❌ Failed to fetch package versions"
            exit 1
          fi
          
          # Check if we got valid JSON
          if ! jq empty raw_versions.json 2>/dev/null; then
            echo "❌ Invalid JSON response:"
            cat raw_versions.json
            exit 1
          fi
          
          # Process the versions - get more detailed info to understand relationships
          jq -c '.[] | {id: .id, name: .name, tags: .metadata.container.tags, created_at: .created_at, updated_at: .updated_at}' raw_versions.json > all_versions.json
          
          # Let's examine the structure to understand relationships
          echo "🔍 Analyzing image relationships..."
          echo "Sample of different image types:"
          
          # Show tagged vs untagged examples
          echo "Tagged images (sample):"
          jq -r 'select(.tags | length > 0) | "ID: \(.id), Name: \(.name), Tags: \(.tags | join(" ")), Created: \(.created_at)"' all_versions.json | head -3
          
          echo -e "\nUntagged images (sample):"  
          jq -r 'select(.tags | length == 0) | "ID: \(.id), Name: \(.name), Created: \(.created_at)"' all_versions.json | head -3
          
          # VERIFICATION: Let's prove the timestamp relationship theory
          echo -e "\nTESTING TIMESTAMP GROUPING THEORY:"
          echo "Looking at the most recent tagged image and what was created at the same time..."
          
          # Get the most recent tagged image
          latest_tagged=$(jq -r 'select(.tags | length > 0) | "\(.created_at) \(.id) \(.tags | join(","))"' all_versions.json | sort -r | head -1)
          echo "Latest tagged: $latest_tagged"
          
          # Extract its timestamp
          latest_timestamp=$(echo "$latest_tagged" | cut -d' ' -f1)
          echo "Its timestamp: $latest_timestamp"
          
          # Find ALL images with that exact timestamp
          echo "ALL images created at exactly $latest_timestamp:"
          jq -r --arg ts "$latest_timestamp" 'select(.created_at == $ts) | "  ID: \(.id), Tags: \(.tags | join(" ") // "NONE"), Name: \(.name)"' all_versions.json
          
          # Count them
          same_time_count=$(jq -r --arg ts "$latest_timestamp" 'select(.created_at == $ts) | .id' all_versions.json | wc -l)
          echo "Total images at this exact timestamp: $same_time_count"
          
          echo -e "\nThis will help us verify if same-timestamp = same-build"

          echo "📦 Processing package versions..."

          # PRECISE APPROACH: Group by exact timestamp (same second = same build)
          echo "🔗 Grouping images by build time..."
          
          # Get all tagged versions we want to keep (semver + 15 most recent main/SHA)
          jq -r 'select(.tags[]? | test("^v?[0-9]+\\.[0-9]+\\.[0-9]+")) | "\(.created_at) \(.id)"' all_versions.json > semver_timestamps.txt
          jq -r 'select(.tags[]? | test("^main$|^sha-[a-f0-9]{7}$")) | "\(.created_at) \(.id)"' all_versions.json | \
            sort -r | head -15 > main_sha_timestamps.txt
          
          # For each keeper version, find ALL versions with the same creation time (to the second)
          > keep_with_related.txt
          
          while IFS=' ' read -r timestamp version_id; do
            if [ -n "$timestamp" ] && [ -n "$version_id" ]; then
              # Find all versions created in the same second (same multi-arch build)
              jq -r --arg ts "$timestamp" 'select(.created_at == $ts) | .id' all_versions.json >> keep_with_related.txt
            fi
          done < <(cat semver_timestamps.txt main_sha_timestamps.txt)
          
          # Remove duplicates and sort
          sort -u keep_with_related.txt > keep_all.txt
          
          # Count for summary
          semver_count=$(wc -l < semver_timestamps.txt 2>/dev/null || echo 0)
          main_sha_count=$(wc -l < main_sha_timestamps.txt 2>/dev/null || echo 0)

          # Get all version IDs and find ones to delete
          jq -r '.id' all_versions.json | sort > all_ids.txt
          comm -23 all_ids.txt keep_all.txt > delete_ids.txt

          # Display summary
          echo "📈 Cleanup Summary (PRECISE GROUPING):"
          echo "  Total versions: $(wc -l < all_ids.txt)"
          echo "  Semver versions (tagged): $semver_count"
          echo "  Main/SHA versions (15 most recent): $main_sha_count"
          echo "  Total keeping (including same-second multi-arch): $(wc -l < keep_all.txt)"
          echo "  Would delete: $(wc -l < delete_ids.txt)"
          echo "  🔗 Groups images by exact creation timestamp (same build = keep together)"

          # Show what would be deleted
          if [ -s delete_ids.txt ]; then
            echo "🔍 Versions that would be deleted:"
            while IFS= read -r version_id; do
              if [ -n "$version_id" ]; then
                tags=$(jq -r --arg id "$version_id" 'select(.id == ($id | tonumber)) | .tags[]?' all_versions.json | tr '\n' ' ')
                echo "  ID: $version_id, Tags: $tags"
              fi
            done < delete_ids.txt

            # Actually delete if not dry run
            if [ "$DRY_RUN" = "true" ]; then
              echo "✅ Dry run completed - no images deleted"
            else
              echo "🗑️  Deleting old package versions..."
              while IFS= read -r version_id; do
                if [ -n "$version_id" ]; then
                  echo "Deleting version ID: $version_id"
                  gh api --method DELETE "users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME/versions/$version_id" || echo "Failed to delete $version_id"
                  sleep 1 # Rate limiting
                fi
              done < delete_ids.txt
              echo "✅ Cleanup completed!"
            fi
          else
            echo "✅ No versions to delete."
          fi

          # Cleanup temp files
          rm -f *.txt *.json
