name: Cleanup Docker Images

on:
  schedule:
    # Run weekly on Sundays at 2 AM UTC
    - cron: "0 2 * * 0"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Dry run mode (just show what would be deleted)"
        required: false
        default: true
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup Docker images
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ github.event_name == 'workflow_dispatch' && inputs.dry_run || 'false' }}
        run: |
          set -e
          set -x  # Enable debug output

          if [ "$DRY_RUN" = "true" ]; then
            echo "🔍 DRY RUN MODE - No images will be deleted"
          else
            echo "🗑️  CLEANUP MODE - Images will be deleted"
          fi

          echo "🔍 Fetching all package versions..."

          # Get package name
          PACKAGE_NAME=$(echo "${{ github.repository }}" | cut -d'/' -f2)

          # Get all package versions
          if ! gh api --paginate "users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME/versions" > raw_versions.json; then
            echo "❌ Failed to fetch package versions"
            exit 1
          fi

          # Process the versions
          jq -c '.[] | {id: .id, name: .name, tags: .metadata.container.tags, created_at: .created_at}' raw_versions.json > all_versions.json

          echo "📦 Processing package versions..."

          # Create detailed keep/delete lists with reasons
          > keep_reasons.txt
          > delete_reasons.txt
          
          # Process each version and determine fate with reason
          echo "Processing $(wc -l < all_versions.json) versions..."
          line_count=0
          while IFS= read -r line; do
            line_count=$((line_count + 1))
            if [ $((line_count % 100)) -eq 0 ]; then
              echo "Processed $line_count versions..."
            fi
            id=$(echo "$line" | jq -r '.id' 2>/dev/null)
            tags=$(echo "$line" | jq -r '.tags | join(" ")' 2>/dev/null)
            name=$(echo "$line" | jq -r '.name' 2>/dev/null)
            created=$(echo "$line" | jq -r '.created_at' 2>/dev/null)
            
            if [ -z "$id" ] || [ "$id" = "null" ]; then
              echo "Warning: Invalid line: $line"
              continue
            fi
            
            reason=""
            keep=false
            
            # Check if it's a semver version (has version number tags but not ONLY sha tags)
            has_version=$(echo "$tags" | grep -o -E '\b[0-9]+(\.[0-9]+)*\b' | head -1)
            has_sha=$(echo "$tags" | grep -c 'sha-')
            
            if [ -n "$has_version" ]; then
              if echo "$tags" | grep -q -E '\b[0-9]+\.[0-9]+\.[0-9]+\b'; then
                reason="semver-version-full"
              elif echo "$tags" | grep -q -E '\b[0-9]+\.[0-9]+\b'; then
                reason="semver-version-major-minor"
              elif echo "$tags" | grep -q -E '\b[0-9]+\b'; then
                reason="semver-version-major"
              fi
              keep=true
            # Check if it's in the 15 most recent main/SHA versions
            elif echo "$tags" | grep -q -E '\b(main|sha-[a-f0-9]{7})\b'; then
              # Create temp file with timestamped main/SHA versions
              jq -r 'select(.tags[]? | test("^main$|^sha-[a-f0-9]{7}$")) | "\(.created_at) \(.id)"' all_versions.json | \
                sort -r | head -15 > recent_main_sha.tmp
              
              # Check if this ID is in the recent list and get its rank
              rank=$(grep " $id$" recent_main_sha.tmp | head -1)
              if [ -n "$rank" ]; then
                # Get line number (rank)
                rank_num=$(grep -n " $id$" recent_main_sha.tmp | cut -d: -f1 | head -1)
                reason="recent-main-SHA-rank-$rank_num-of-15"
                keep=true
              else
                reason="old-main-SHA-older-than-15-most-recent"
              fi
            # Check if it has no tags (untagged multi-arch image)
            elif [ -z "$tags" ] || [ "$tags" = " " ]; then
              reason="untagged-likely-multi-arch-artifact"
            # Has other tags (branch, etc.)
            else
              reason="branch-or-other-tags"
            fi
            
            if [ "$keep" = true ]; then
              echo "$id|$reason" >> keep_reasons.txt
            else
              echo "$id|$reason" >> delete_reasons.txt
            fi
          done < all_versions.json
          
          echo "Completed processing $line_count versions"
          echo "Keep decisions: $(wc -l < keep_reasons.txt)"
          echo "Delete decisions: $(wc -l < delete_reasons.txt)"
          
          # Now find multi-arch images related to kept versions
          echo "🔗 Finding multi-arch images related to kept versions..."
          
          # Debug: show what we initially decided to keep
          echo "Debug: Initial keep decisions:"
          total_keep=$(wc -l < keep_reasons.txt)
          semver_keep=$(grep "semver version" keep_reasons.txt | wc -l)
          mainsha_keep=$(grep "recent main/SHA" keep_reasons.txt | wc -l)
          echo "Total initial keep decisions: $total_keep"
          echo "Semver versions: $semver_keep"
          echo "Main/SHA versions: $mainsha_keep"
          
          echo "Main/SHA versions being kept:"
          grep "recent main/SHA" keep_reasons.txt || echo "No main/SHA versions found"
          
          > keep_with_manifests.txt
          
          while IFS='|' read -r version_id reason; do
            if [ -n "$version_id" ]; then
              echo "$version_id|$reason" >> keep_with_manifests.txt
              
              # Get the manifest SHA for this version
              manifest_sha=$(jq -r --arg id "$version_id" 'select(.id == ($id | tonumber)) | .name' all_versions.json)
              
              if [ -n "$manifest_sha" ]; then
                # Get manifest from Docker registry
                if manifest_info=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
                  "https://ghcr.io/v2/${{ github.repository_owner }}/$PACKAGE_NAME/manifests/${manifest_sha#sha256:}" \
                  -H "Accept: application/vnd.docker.distribution.manifest.list.v2+json,application/vnd.docker.distribution.manifest.v2+json" 2>/dev/null); then
                  
                  # Extract referenced digests and find their version IDs
                  echo "$manifest_info" | jq -r '.manifests[]?.digest // empty' 2>/dev/null | while read -r digest; do
                    if [ -n "$digest" ]; then
                      related_id=$(jq -r --arg sha "$digest" 'select(.name == $sha) | .id' all_versions.json)
                      if [ -n "$related_id" ] && [ "$related_id" != "$version_id" ]; then
                        echo "$related_id|multi-arch-component-of-$version_id-$reason" >> keep_with_manifests.txt
                        # Remove from delete list if it was there
                        grep -v "^$related_id|" delete_reasons.txt > delete_reasons_temp.txt 2>/dev/null || touch delete_reasons_temp.txt
                        mv delete_reasons_temp.txt delete_reasons.txt
                      fi
                    fi
                  done
                fi
              fi
            fi
          done < keep_reasons.txt
          
          # Verify we have data - fail if API doesn't work
          if [ ! -s keep_with_manifests.txt ]; then
            echo "❌ Cannot determine manifest relationships - aborting cleanup"
            exit 1
          fi
          
          # Create final keep list (just IDs) - ensure proper numeric sorting and remove empty lines
          cut -d'|' -f1 keep_with_manifests.txt | grep -E '^[0-9]+$' | sort -n | uniq > keep_all.txt

          # Get all version IDs and find ones to delete - ensure proper numeric sorting  
          jq -r '.id' all_versions.json | grep -E '^[0-9]+$' | sort -n > all_ids.txt
          
          # Debug: check if files are properly sorted
          echo "Debug: First 5 lines of all_ids.txt:"
          head -5 all_ids.txt
          echo "Debug: First 5 lines of keep_all.txt:"
          head -5 keep_all.txt
          echo "Debug: Last 5 lines of all_ids.txt:"
          tail -5 all_ids.txt
          echo "Debug: Last 5 lines of keep_all.txt:"
          tail -5 keep_all.txt
          
          # Use a safer approach - create delete list manually
          > delete_ids.txt
          while IFS= read -r id; do
            if ! grep -q "^$id$" keep_all.txt; then
              echo "$id" >> delete_ids.txt
            fi
          done < all_ids.txt

          # Display summary with detailed reasons
          semver_count=$(grep "semver version" keep_with_manifests.txt | wc -l)
          main_sha_count=$(grep "recent main/SHA" keep_with_manifests.txt | wc -l)

          echo "📈 Cleanup Summary:"
          echo "  Total versions: $(wc -l < all_ids.txt)"
          echo "  Semver versions: $semver_count"
          echo "  Main/SHA versions (15 most recent): $main_sha_count"
          echo "  Total keeping (including multi-arch): $(wc -l < keep_all.txt)"
          echo "  Would delete: $(wc -l < delete_ids.txt)"

          # Show what we're keeping and why
          echo ""
          echo "✅ Versions being kept:"
          while IFS='|' read -r version_id reason; do
            if [ -n "$version_id" ]; then
              tags=$(jq -r --arg id "$version_id" 'select(.id == ($id | tonumber)) | .tags | join(" ")' all_versions.json)
              # Convert reason back to readable format
              readable_reason=$(echo "$reason" | sed 's/-/ /g' | sed 's/rank \([0-9]*\) of 15/(#\1 of 15)/')
              echo "  ID: $version_id, Tags: $tags, Reason: $readable_reason"
            fi
          done < keep_with_manifests.txt

          # Show what would be deleted and why
          echo ""
          if [ -s delete_reasons.txt ]; then
            echo "🗑️  Versions that would be deleted:"
            while IFS='|' read -r version_id reason; do
              if [ -n "$version_id" ]; then
                tags=$(jq -r --arg id "$version_id" 'select(.id == ($id | tonumber)) | .tags | join(" ")' all_versions.json)
                # Convert reason back to readable format
                readable_reason=$(echo "$reason" | sed 's/-/ /g')
                echo "  ID: $version_id, Tags: $tags, Reason: $readable_reason"
              fi
            done < delete_reasons.txt

            # Actually delete if not dry run
            if [ "$DRY_RUN" = "true" ]; then
              echo "✅ Dry run completed - no images deleted"
            else
              echo "🗑️  Deleting old package versions..."
              while IFS= read -r version_id; do
                if [ -n "$version_id" ]; then
                  echo "Deleting version ID: $version_id"
                  gh api --method DELETE "users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME/versions/$version_id" || echo "Failed to delete $version_id"
                  sleep 1 # Rate limiting
                fi
              done < delete_ids.txt
              echo "✅ Cleanup completed!"
            fi
          else
            echo "✅ No versions to delete."
          fi

          # Cleanup temp files
          rm -f *.txt *.json
