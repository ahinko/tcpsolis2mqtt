name: Cleanup Docker Images

on:
  schedule:
    # Run weekly on Sundays at 2 AM UTC
    - cron: "0 2 * * 0"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Dry run mode (just show what would be deleted)"
        required: false
        default: true
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup Docker images
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ github.event_name == 'workflow_dispatch' && inputs.dry_run || 'false' }}
        run: |
          set -e

          if [ "$DRY_RUN" = "true" ]; then
            echo "ðŸ” DRY RUN MODE - No images will be deleted"
          else
            echo "ðŸ—‘ï¸  CLEANUP MODE - Images will be deleted"
          fi

          echo "ðŸ” Fetching all package versions..."

          # Get all package versions (using user endpoint)
          PACKAGE_NAME=$(echo "${{ github.repository }}" | cut -d'/' -f2)
          echo "Looking for package: $PACKAGE_NAME"
          echo "Owner: ${{ github.repository_owner }}"
          
          # First check if we can access the package
          if ! gh api "users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME" > /dev/null 2>&1; then
            echo "âŒ Cannot access package. Available packages:"
            gh api "users/${{ github.repository_owner }}/packages?package_type=container" --jq '.[].name' || echo "No packages found"
            exit 1
          fi
          
          # Get all package versions
          if ! gh api --paginate "users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME/versions" > raw_versions.json; then
            echo "âŒ Failed to fetch package versions"
            exit 1
          fi
          
          # Check if we got valid JSON
          if ! jq empty raw_versions.json 2>/dev/null; then
            echo "âŒ Invalid JSON response:"
            cat raw_versions.json
            exit 1
          fi
          
          # Process the versions - get more detailed info to understand relationships
          jq -c '.[] | {id: .id, name: .name, tags: .metadata.container.tags, created_at: .created_at, updated_at: .updated_at}' raw_versions.json > all_versions.json
          
          # Let's examine the structure to understand relationships
          echo "ðŸ” Analyzing image relationships..."
          echo "Sample of different image types:"
          
          # Show tagged vs untagged examples
          echo "Tagged images (sample):"
          jq -r 'select(.tags | length > 0) | "ID: \(.id), Name: \(.name), Tags: \(.tags | join(" ")), Created: \(.created_at)"' all_versions.json | head -3
          
          echo -e "\nUntagged images (sample):"  
          jq -r 'select(.tags | length == 0) | "ID: \(.id), Name: \(.name), Created: \(.created_at)"' all_versions.json | head -3
          
          

          echo "ðŸ“¦ Processing package versions..."

          # MANIFEST-BASED APPROACH: Use Docker Registry API to find related images
          echo "ðŸ”— Using Docker Registry API to find manifest relationships..."
          
          # Get tagged versions we want to keep
          jq -r 'select(.tags[]? | test("^v?[0-9]+\\.[0-9]+\\.[0-9]+")) | "\(.id) \(.name)"' all_versions.json > keeper_semver.txt
          jq -r 'select(.tags[]? | test("^main$|^sha-[a-f0-9]{7}$")) | "\(.created_at) \(.id) \(.name)"' all_versions.json | \
            sort -r | head -15 | cut -d' ' -f2,3 > keeper_main_sha.txt
          
          # For each keeper manifest, get its architecture-specific images
          > keep_with_manifests.txt
          
          while IFS=' ' read -r version_id manifest_sha; do
            if [ -n "$version_id" ] && [ -n "$manifest_sha" ]; then
              echo "$version_id" >> keep_with_manifests.txt
              
              # Get the manifest from Docker registry to see what it references
              echo "Checking manifest for version $version_id ($manifest_sha)..."
              
              # Try to get manifest - this will show us referenced image SHAs
              if manifest_info=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
                "https://ghcr.io/v2/ahinko/tcpsolis2mqtt/manifests/${manifest_sha#sha256:}" \
                -H "Accept: application/vnd.docker.distribution.manifest.list.v2+json,application/vnd.docker.distribution.manifest.v2+json" 2>/dev/null); then
                
                # Extract referenced digests and find their version IDs
                echo "$manifest_info" | jq -r '.manifests[]?.digest // empty' 2>/dev/null | while read -r digest; do
                  if [ -n "$digest" ]; then
                    # Find version ID for this digest
                    jq -r --arg sha "$digest" 'select(.name == $sha) | .id' all_versions.json >> keep_with_manifests.txt
                  fi
                done
              fi
            fi
          done < <(cat keeper_semver.txt keeper_main_sha.txt)
          
          # Verify we got manifest data - fail if Docker Registry API doesn't work
          if [ ! -s keep_with_manifests.txt ]; then
            echo "âŒ Docker Registry API failed - cannot determine manifest relationships"
            echo "âŒ Aborting cleanup to prevent accidental deletion of related images"
            exit 1
          fi
          
          # Remove duplicates and sort
          sort -nu keep_with_manifests.txt > keep_all.txt
          
          # Count for summary
          semver_count=$(wc -l < keeper_semver.txt 2>/dev/null || echo 0)
          main_sha_count=$(wc -l < keeper_main_sha.txt 2>/dev/null || echo 0)

          # Get all version IDs and find ones to delete
          jq -r '.id' all_versions.json | sort > all_ids.txt
          comm -23 all_ids.txt keep_all.txt > delete_ids.txt

          # Display summary
          echo "ðŸ“ˆ Cleanup Summary (PRECISE GROUPING):"
          echo "  Total versions: $(wc -l < all_ids.txt)"
          echo "  Semver versions (tagged): $semver_count"
          echo "  Main/SHA versions (15 most recent): $main_sha_count"
          echo "  Total keeping (including same-second multi-arch): $(wc -l < keep_all.txt)"
          echo "  Would delete: $(wc -l < delete_ids.txt)"
          echo "  ðŸ”— Groups images by exact creation timestamp (same build = keep together)"

          # Show what would be deleted
          if [ -s delete_ids.txt ]; then
            echo "ðŸ” Versions that would be deleted:"
            while IFS= read -r version_id; do
              if [ -n "$version_id" ]; then
                tags=$(jq -r --arg id "$version_id" 'select(.id == ($id | tonumber)) | .tags[]?' all_versions.json | tr '\n' ' ')
                echo "  ID: $version_id, Tags: $tags"
              fi
            done < delete_ids.txt

            # Actually delete if not dry run
            if [ "$DRY_RUN" = "true" ]; then
              echo "âœ… Dry run completed - no images deleted"
            else
              echo "ðŸ—‘ï¸  Deleting old package versions..."
              while IFS= read -r version_id; do
                if [ -n "$version_id" ]; then
                  echo "Deleting version ID: $version_id"
                  gh api --method DELETE "users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME/versions/$version_id" || echo "Failed to delete $version_id"
                  sleep 1 # Rate limiting
                fi
              done < delete_ids.txt
              echo "âœ… Cleanup completed!"
            fi
          else
            echo "âœ… No versions to delete."
          fi

          # Cleanup temp files
          rm -f *.txt *.json
