name: Cleanup Docker Images

on:
  schedule:
    # Run weekly on Sundays at 2 AM UTC
    - cron: "0 2 * * 0"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Dry run mode (just show what would be deleted)"
        required: false
        default: true
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup Docker images
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ github.event_name == 'workflow_dispatch' && inputs.dry_run || 'false' }}
        run: |
          set -e

          if [ "$DRY_RUN" = "true" ]; then
            echo "🔍 DRY RUN MODE - No images will be deleted"
          else
            echo "🗑️  CLEANUP MODE - Images will be deleted"
          fi

          echo "🔍 Fetching all package versions..."

          # Get package name
          PACKAGE_NAME=$(echo "${{ github.repository }}" | cut -d'/' -f2)

          # Get all package versions
          if ! gh api --paginate "users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME/versions" > raw_versions.json; then
            echo "❌ Failed to fetch package versions"
            exit 1
          fi

          # Process the versions
          jq -c '.[] | {id: .id, name: .name, tags: .metadata.container.tags, created_at: .created_at}' raw_versions.json > all_versions.json

          echo "📦 Processing package versions..."

          # Create detailed keep/delete lists with reasons
          > keep_reasons.txt
          > delete_reasons.txt
          
          # Process each version and determine fate with reason
          while IFS= read -r line; do
            id=$(echo "$line" | jq -r '.id')
            tags=$(echo "$line" | jq -r '.tags | join(" ")')
            name=$(echo "$line" | jq -r '.name')
            created=$(echo "$line" | jq -r '.created_at')
            
            reason=""
            keep=false
            
            # Check if it's a semver version
            if echo "$tags" | grep -q -E '\bv?[0-9]+\.[0-9]+\.[0-9]+\b'; then
              reason="semver version"
              keep=true
            # Check if it's in the 15 most recent main/SHA versions
            elif echo "$tags" | grep -q -E '\b(main|sha-[a-f0-9]{7})\b'; then
              # Get the 15 most recent main/SHA IDs
              recent_ids=$(jq -r 'select(.tags[]? | test("^main$|^sha-[a-f0-9]{7}$")) | "\(.created_at) \(.id)"' all_versions.json | \
                sort -r | head -15 | cut -d' ' -f2)
              
              # Check if this ID is in the recent list
              if echo "$recent_ids" | grep -q "^$id$"; then
                rank=$(jq -r 'select(.tags[]? | test("^main$|^sha-[a-f0-9]{7}$")) | "\(.created_at) \(.id)"' all_versions.json | \
                  sort -r | head -15 | nl -nln | grep " $id$" | cut -f1)
                reason="recent main/SHA (#$rank of 15)"
                keep=true
              else
                reason="old main/SHA (older than 15 most recent)"
              fi
            # Check if it has no tags (untagged multi-arch image)
            elif [ -z "$tags" ] || [ "$tags" = " " ]; then
              reason="untagged (likely multi-arch artifact)"
            # Has other tags (branch, etc.)
            else
              reason="branch/other tags: $tags"
            fi
            
            if [ "$keep" = true ]; then
              echo "$id $reason" >> keep_reasons.txt
            else
              echo "$id $reason" >> delete_reasons.txt
            fi
          done < all_versions.json
          
          # Now find multi-arch images related to kept versions
          echo "🔗 Finding multi-arch images related to kept versions..."
          > keep_with_manifests.txt
          
          while IFS=' ' read -r version_id reason; do
            if [ -n "$version_id" ]; then
              echo "$version_id $reason" >> keep_with_manifests.txt
              
              # Get the manifest SHA for this version
              manifest_sha=$(jq -r --arg id "$version_id" 'select(.id == ($id | tonumber)) | .name' all_versions.json)
              
              if [ -n "$manifest_sha" ]; then
                # Get manifest from Docker registry
                if manifest_info=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
                  "https://ghcr.io/v2/${{ github.repository_owner }}/$PACKAGE_NAME/manifests/${manifest_sha#sha256:}" \
                  -H "Accept: application/vnd.docker.distribution.manifest.list.v2+json,application/vnd.docker.distribution.manifest.v2+json" 2>/dev/null); then
                  
                  # Extract referenced digests and find their version IDs
                  echo "$manifest_info" | jq -r '.manifests[]?.digest // empty' 2>/dev/null | while read -r digest; do
                    if [ -n "$digest" ]; then
                      related_id=$(jq -r --arg sha "$digest" 'select(.name == $sha) | .id' all_versions.json)
                      if [ -n "$related_id" ] && [ "$related_id" != "$version_id" ]; then
                        echo "$related_id multi-arch component of $version_id ($reason)" >> keep_with_manifests.txt
                        # Remove from delete list if it was there
                        grep -v "^$related_id " delete_reasons.txt > delete_reasons_temp.txt 2>/dev/null || touch delete_reasons_temp.txt
                        mv delete_reasons_temp.txt delete_reasons.txt
                      fi
                    fi
                  done
                fi
              fi
            fi
          done < keep_reasons.txt
          
          # Verify we have data - fail if API doesn't work
          if [ ! -s keep_with_manifests.txt ]; then
            echo "❌ Cannot determine manifest relationships - aborting cleanup"
            exit 1
          fi
          
          # Create final keep list (just IDs) - ensure proper numeric sorting and remove empty lines
          cut -d' ' -f1 keep_with_manifests.txt | grep -E '^[0-9]+$' | sort -n | uniq > keep_all.txt

          # Get all version IDs and find ones to delete - ensure proper numeric sorting  
          jq -r '.id' all_versions.json | grep -E '^[0-9]+$' | sort -n > all_ids.txt
          
          # Debug: check if files are properly sorted
          echo "Debug: First 5 lines of all_ids.txt:"
          head -5 all_ids.txt
          echo "Debug: First 5 lines of keep_all.txt:"
          head -5 keep_all.txt
          echo "Debug: Last 5 lines of all_ids.txt:"
          tail -5 all_ids.txt
          echo "Debug: Last 5 lines of keep_all.txt:"
          tail -5 keep_all.txt
          
          # Use a safer approach - create delete list manually
          > delete_ids.txt
          while IFS= read -r id; do
            if ! grep -q "^$id$" keep_all.txt; then
              echo "$id" >> delete_ids.txt
            fi
          done < all_ids.txt

          # Display summary with detailed reasons
          semver_count=$(grep "semver version" keep_with_manifests.txt | wc -l)
          main_sha_count=$(grep "recent main/SHA" keep_with_manifests.txt | wc -l)

          echo "📈 Cleanup Summary:"
          echo "  Total versions: $(wc -l < all_ids.txt)"
          echo "  Semver versions: $semver_count"
          echo "  Main/SHA versions (15 most recent): $main_sha_count"
          echo "  Total keeping (including multi-arch): $(wc -l < keep_all.txt)"
          echo "  Would delete: $(wc -l < delete_ids.txt)"

          # Show what we're keeping and why
          echo ""
          echo "✅ Versions being kept:"
          while IFS=' ' read -r version_id reason_part; do
            if [ -n "$version_id" ]; then
              # Reconstruct the full reason (everything after the first space)
              reason=$(echo "$version_id $reason_part" | cut -d' ' -f2-)
              tags=$(jq -r --arg id "$version_id" 'select(.id == ($id | tonumber)) | .tags | join(" ")' all_versions.json)
              echo "  ID: $version_id, Tags: $tags, Reason: $reason"
            fi
          done < keep_with_manifests.txt

          # Show what would be deleted and why
          echo ""
          if [ -s delete_reasons.txt ]; then
            echo "🗑️  Versions that would be deleted:"
            while IFS=' ' read -r version_id reason_part; do
              if [ -n "$version_id" ]; then
                # Reconstruct the full reason (everything after the first space)
                reason=$(echo "$version_id $reason_part" | cut -d' ' -f2-)
                tags=$(jq -r --arg id "$version_id" 'select(.id == ($id | tonumber)) | .tags | join(" ")' all_versions.json)
                echo "  ID: $version_id, Tags: $tags, Reason: $reason"
              fi
            done < delete_reasons.txt

            # Actually delete if not dry run
            if [ "$DRY_RUN" = "true" ]; then
              echo "✅ Dry run completed - no images deleted"
            else
              echo "🗑️  Deleting old package versions..."
              while IFS= read -r version_id; do
                if [ -n "$version_id" ]; then
                  echo "Deleting version ID: $version_id"
                  gh api --method DELETE "users/${{ github.repository_owner }}/packages/container/$PACKAGE_NAME/versions/$version_id" || echo "Failed to delete $version_id"
                  sleep 1 # Rate limiting
                fi
              done < delete_ids.txt
              echo "✅ Cleanup completed!"
            fi
          else
            echo "✅ No versions to delete."
          fi

          # Cleanup temp files
          rm -f *.txt *.json
